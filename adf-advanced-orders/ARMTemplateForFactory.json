{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adf-advanced-orders"
		},
		"AzureSqlDatabase1_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzureSqlDatabase1'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=adfadvancedorders.database.windows.net;Initial Catalog=adf_orders_advanced;User ID=sreejit"
		},
		"AzureBlobStorage1_properties_typeProperties_serviceEndpoint": {
			"type": "string",
			"defaultValue": "https://adfadvancedorders.blob.core.windows.net/"
		},
		"AzureDataLakeStorage1_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://adfadvancedordersdl.dfs.core.windows.net/"
		},
		"AzureKeyVault1_properties_typeProperties_baseUrl": {
			"type": "string",
			"defaultValue": "https://kvadfadvanced.vault.azure.net/"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/pl_cleansed_to_structured')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_cleaned_to_structured",
								"type": "DataFlowReference",
								"parameters": {
									"curr_date": "toString(currentDate('UTC'),'yyyy-MM-dd')",
									"schema_name": {
										"value": "'@{pipeline().parameters.schema_name}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {},
									"source2": {},
									"source3": {},
									"source4": {},
									"sink3": {},
									"sink4": {},
									"sink5": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"schema_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-09T06:04:26Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_cleaned_to_structured')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_cpy_blob_dl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "read files lookup",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "set azure sql schema names per env",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "ds_read_lookup",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "iterate_lookup_file",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "read files lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('read files lookup').output.value[0].data",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "set_ip_filename",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "input_file",
										"value": {
											"value": "@item().SOURCE_FILE",
											"type": "Expression"
										}
									}
								},
								{
									"name": "set_op_filename",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "output_file",
										"value": {
											"value": "@item().TARGET_FILE",
											"type": "Expression"
										}
									}
								},
								{
									"name": "copy_based_on_file",
									"type": "Switch",
									"dependsOn": [
										{
											"activity": "set_op_filename",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "set_ip_filename",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"on": {
											"value": "@split(variables('input_file'), '.')[sub(length(split(variables('input_file'), '.')), 1)]\n\n",
											"type": "Expression"
										},
										"cases": [
											{
												"value": "json",
												"activities": [
													{
														"name": "copy_blob_datalake",
														"type": "Copy",
														"dependsOn": [],
														"policy": {
															"timeout": "0.12:00:00",
															"retry": 0,
															"retryIntervalInSeconds": 30,
															"secureOutput": false,
															"secureInput": false
														},
														"userProperties": [],
														"typeProperties": {
															"source": {
																"type": "JsonSource",
																"storeSettings": {
																	"type": "AzureBlobStorageReadSettings",
																	"recursive": true,
																	"enablePartitionDiscovery": false
																},
																"formatSettings": {
																	"type": "JsonReadSettings"
																}
															},
															"sink": {
																"type": "JsonSink",
																"storeSettings": {
																	"type": "AzureBlobFSWriteSettings",
																	"copyBehavior": "FlattenHierarchy"
																},
																"formatSettings": {
																	"type": "JsonWriteSettings"
																}
															},
															"enableStaging": false
														},
														"inputs": [
															{
																"referenceName": "ds_blob_json",
																"type": "DatasetReference",
																"parameters": {
																	"file_name": {
																		"value": "@variables('input_file')",
																		"type": "Expression"
																	}
																}
															}
														],
														"outputs": [
															{
																"referenceName": "ds_json_datalake_landing",
																"type": "DatasetReference",
																"parameters": {
																	"file_name": {
																		"value": "@variables('output_file')",
																		"type": "Expression"
																	},
																	"curr_date": {
																		"value": "@formatDateTime(utcnow(),'yyyy-MM-dd')",
																		"type": "Expression"
																	}
																}
															}
														]
													},
													{
														"name": "Execute Pipeline2",
														"type": "ExecutePipeline",
														"dependsOn": [
															{
																"activity": "copy_blob_datalake",
																"dependencyConditions": [
																	"Succeeded"
																]
															}
														],
														"userProperties": [],
														"typeProperties": {
															"pipeline": {
																"referenceName": "pl_raw_to_cleansed_for_json",
																"type": "PipelineReference"
															},
															"waitOnCompletion": true,
															"parameters": {
																"file_name": {
																	"value": "@variables('output_file')",
																	"type": "Expression"
																}
															}
														}
													}
												]
											},
											{
												"value": "txt",
												"activities": [
													{
														"name": "copy_txt",
														"type": "Copy",
														"dependsOn": [],
														"policy": {
															"timeout": "0.12:00:00",
															"retry": 0,
															"retryIntervalInSeconds": 30,
															"secureOutput": false,
															"secureInput": false
														},
														"userProperties": [],
														"typeProperties": {
															"source": {
																"type": "DelimitedTextSource",
																"storeSettings": {
																	"type": "AzureBlobStorageReadSettings",
																	"recursive": true,
																	"enablePartitionDiscovery": false
																},
																"formatSettings": {
																	"type": "DelimitedTextReadSettings"
																}
															},
															"sink": {
																"type": "DelimitedTextSink",
																"storeSettings": {
																	"type": "AzureBlobFSWriteSettings"
																},
																"formatSettings": {
																	"type": "DelimitedTextWriteSettings",
																	"quoteAllText": true,
																	"fileExtension": ".txt"
																}
															},
															"enableStaging": false,
															"translator": {
																"type": "TabularTranslator",
																"typeConversion": true,
																"typeConversionSettings": {
																	"allowDataTruncation": true,
																	"treatBooleanAsNumber": false
																}
															}
														},
														"inputs": [
															{
																"referenceName": "ds_blob_text",
																"type": "DatasetReference",
																"parameters": {
																	"file_name": {
																		"value": "@variables('input_file')",
																		"type": "Expression"
																	}
																}
															}
														],
														"outputs": [
															{
																"referenceName": "ds_txt_datalake_landing",
																"type": "DatasetReference",
																"parameters": {
																	"filename": {
																		"value": "@variables('output_file')",
																		"type": "Expression"
																	},
																	"curr_date": "@formatDateTime(utcnow(),'yyyy-MM-dd')"
																}
															}
														]
													},
													{
														"name": "Execute Pipeline1",
														"type": "ExecutePipeline",
														"dependsOn": [
															{
																"activity": "copy_txt",
																"dependencyConditions": [
																	"Succeeded"
																]
															}
														],
														"userProperties": [],
														"typeProperties": {
															"pipeline": {
																"referenceName": "pl_raw-to_cleansed_for_text",
																"type": "PipelineReference"
															},
															"waitOnCompletion": true,
															"parameters": {
																"filename": {
																	"value": "@variables('output_file')",
																	"type": "Expression"
																}
															}
														}
													}
												]
											},
											{
												"value": "parquet",
												"activities": [
													{
														"name": "Copy data1",
														"type": "Copy",
														"dependsOn": [],
														"policy": {
															"timeout": "0.12:00:00",
															"retry": 0,
															"retryIntervalInSeconds": 30,
															"secureOutput": false,
															"secureInput": false
														},
														"userProperties": [],
														"typeProperties": {
															"source": {
																"type": "ParquetSource",
																"storeSettings": {
																	"type": "AzureBlobStorageReadSettings",
																	"recursive": true,
																	"enablePartitionDiscovery": false
																},
																"formatSettings": {
																	"type": "ParquetReadSettings"
																}
															},
															"sink": {
																"type": "ParquetSink",
																"storeSettings": {
																	"type": "AzureBlobFSWriteSettings"
																},
																"formatSettings": {
																	"type": "ParquetWriteSettings"
																}
															},
															"enableStaging": false,
															"translator": {
																"type": "TabularTranslator",
																"typeConversion": true,
																"typeConversionSettings": {
																	"allowDataTruncation": true,
																	"treatBooleanAsNumber": false
																}
															}
														},
														"inputs": [
															{
																"referenceName": "ds_blob_parquet",
																"type": "DatasetReference",
																"parameters": {
																	"filename": {
																		"value": "@variables('input_file')",
																		"type": "Expression"
																	}
																}
															}
														],
														"outputs": [
															{
																"referenceName": "ds_parquet_datalake_landing",
																"type": "DatasetReference",
																"parameters": {
																	"filename": {
																		"value": "@variables('output_file')",
																		"type": "Expression"
																	},
																	"curr_date": {
																		"value": "@formatDateTime(utcnow(),'yyyy-MM-dd')",
																		"type": "Expression"
																	}
																}
															}
														]
													},
													{
														"name": "Execute Pipeline3",
														"type": "ExecutePipeline",
														"dependsOn": [
															{
																"activity": "Copy data1",
																"dependencyConditions": [
																	"Succeeded"
																]
															}
														],
														"userProperties": [],
														"typeProperties": {
															"pipeline": {
																"referenceName": "pl_raw_to_cleansed_for parquet",
																"type": "PipelineReference"
															},
															"waitOnCompletion": true,
															"parameters": {
																"file_name": {
																	"value": "@variables('output_file')",
																	"type": "Expression"
																}
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "Execute Pipeline4",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "iterate_lookup_file",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_cleansed_to_structured",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"schema_name": {
									"value": "@variables('schema_name')",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "Execute Pipeline5",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Pipeline4",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_structured_to_analytics",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"schema_name": {
									"value": "@variables('schema_name')",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "set azure sql schema names per env",
						"type": "Switch",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"on": {
								"value": "@pipeline().globalParameters.environment",
								"type": "Expression"
							},
							"cases": [
								{
									"value": "dev",
									"activities": [
										{
											"name": "Set variable1",
											"type": "SetVariable",
											"dependsOn": [],
											"policy": {
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"variableName": "schema_name",
												"value": {
													"value": "orders",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"input_file": {
						"type": "String"
					},
					"output_file": {
						"type": "String"
					},
					"file_name_lkp_path": {
						"type": "String"
					},
					"folder_name_lookup": {
						"type": "String"
					},
					"cleansed_container": {
						"type": "String"
					},
					"STRUCTURED_CONTAINER": {
						"type": "String"
					},
					"ANALYTICS_CONTAINER": {
						"type": "String"
					},
					"curr_folder": {
						"type": "String"
					},
					"array_all_folders": {
						"type": "Array"
					},
					"schema_name": {
						"type": "String"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-09T06:04:26Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_read_lookup')]",
				"[concat(variables('factoryId'), '/pipelines/pl_cleansed_to_structured')]",
				"[concat(variables('factoryId'), '/pipelines/pl_structured_to_analytics')]",
				"[concat(variables('factoryId'), '/datasets/ds_blob_json')]",
				"[concat(variables('factoryId'), '/datasets/ds_json_datalake_landing')]",
				"[concat(variables('factoryId'), '/pipelines/pl_raw_to_cleansed_for_json')]",
				"[concat(variables('factoryId'), '/datasets/ds_blob_text')]",
				"[concat(variables('factoryId'), '/datasets/ds_txt_datalake_landing')]",
				"[concat(variables('factoryId'), '/pipelines/pl_raw-to_cleansed_for_text')]",
				"[concat(variables('factoryId'), '/datasets/ds_blob_parquet')]",
				"[concat(variables('factoryId'), '/datasets/ds_parquet_datalake_landing')]",
				"[concat(variables('factoryId'), '/pipelines/pl_raw_to_cleansed_for parquet')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_raw-to_cleansed_for_text')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_raw_cleaned_text",
								"type": "DataFlowReference",
								"parameters": {
									"file_name": {
										"value": "'@{pipeline().parameters.filename}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"txt": {
										"filename": {
											"value": "@pipeline().parameters.filename",
											"type": "Expression"
										},
										"curr_date": "@formatDateTime(utcnow(),'yyyy-MM-dd')"
									},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"filename": {
						"type": "string"
					}
				},
				"variables": {
					"curr_folder": {
						"type": "String"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-08T11:28:43Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_raw_cleaned_text')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_raw_to_cleansed_for parquet')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_raw_cleaned_parquet",
								"type": "DataFlowReference",
								"parameters": {
									"file_name": {
										"value": "'@{pipeline().parameters.file_name}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {
										"filename": {
											"value": "@pipeline().parameters.file_name",
											"type": "Expression"
										},
										"curr_date": {
											"value": "@formatDateTime(utcnow(),'yyyy-MM-dd')",
											"type": "Expression"
										}
									},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-08T11:28:43Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_raw_cleaned_parquet')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_raw_to_cleansed_for_json')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_raw_cleansed_json",
								"type": "DataFlowReference",
								"parameters": {
									"file_name": {
										"value": "'@{pipeline().parameters.file_name}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {
										"file_name": {
											"value": "@pipeline().parameters.file_name",
											"type": "Expression"
										},
										"curr_date": "@formatDateTime(utcnow(),'yyyy-MM-dd')"
									},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-08T11:28:43Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_raw_cleansed_json')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_structured_to_analytics')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_structured_analytics",
								"type": "DataFlowReference",
								"parameters": {
									"schema_name": {
										"value": "'@{pipeline().parameters.schema_name}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {},
									"source2": {},
									"source3": {},
									"sink1": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"schema_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"lastPublishTime": "2023-12-09T06:04:26Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_structured_analytics')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_blob_json')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"folder": {
					"name": "blob_datasets"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": "Customer Orders",
						"container": "landing"
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"CUSTOMER_ID": {
							"type": "string"
						},
						"FULL_NAME": {
							"type": "string"
						},
						"EMAIL_ADDRESS": {
							"type": "string"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_blob_parquet')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"filename": {
						"type": "string"
					}
				},
				"folder": {
					"name": "blob_datasets"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": "Customer Orders",
						"container": "landing"
					},
					"compressionCodec": "none"
				},
				"schema": [
					{
						"name": "ORDER_ID",
						"type": "UTF8"
					},
					{
						"name": "ORDER_DATETIME",
						"type": "UTF8"
					},
					{
						"name": "CUSTOMER_ID",
						"type": "UTF8"
					},
					{
						"name": "ORDER_STATUS",
						"type": "UTF8"
					},
					{
						"name": "STORE_ID",
						"type": "UTF8"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_blob_text')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"folder": {
					"name": "blob_datasets"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": "Customer Orders",
						"container": "landing"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_generic_parquet')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"container_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": {
							"value": "@dataset().container_name",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_json_datalake_landing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"file_name": {
						"type": "string"
					},
					"curr_date": {
						"type": "string"
					}
				},
				"folder": {
					"name": "datalake_datasets"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().curr_date",
							"type": "Expression"
						},
						"fileSystem": "raw"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_parquet_datalake_landing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"filename": {
						"type": "string"
					},
					"curr_date": {
						"type": "string"
					}
				},
				"folder": {
					"name": "datalake_datasets"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().curr_date",
							"type": "Expression"
						},
						"fileSystem": "raw"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_read_lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "generic_lookup_configs_datasets"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "lookup_json.txt",
							"type": "Expression"
						},
						"folderPath": "config",
						"container": "landing"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_txt_datalake_landing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureDataLakeStorage1",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"filename": {
						"type": "string"
					},
					"curr_date": {
						"type": "string"
					}
				},
				"folder": {
					"name": "datalake_datasets"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().curr_date",
							"type": "Expression"
						},
						"fileSystem": "raw"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureBlobStorage1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"serviceEndpoint": "[parameters('AzureBlobStorage1_properties_typeProperties_serviceEndpoint')]",
					"accountKind": "StorageV2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureDataLakeStorage1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('AzureDataLakeStorage1_properties_typeProperties_url')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureKeyVault1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureKeyVault",
				"typeProperties": {
					"baseUrl": "[parameters('AzureKeyVault1_properties_typeProperties_baseUrl')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureSqlDatabase1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": "[parameters('AzureSqlDatabase1_connectionString')]",
					"password": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault1",
							"type": "LinkedServiceReference"
						},
						"secretName": "azure-sql-dev-admin"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureKeyVault1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_cleaned_to_structured')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "source1"
						},
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "source2"
						},
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "source3"
						},
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "source4"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "sink3"
						},
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "sink4"
						},
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "sink5"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "cast1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     curr_date as string,",
						"     schema_name as string",
						"}",
						"source(output(",
						"          PRODUCT_ID as string,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as string,",
						"          updated_timestamp as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(\"products/\",$curr_date))) ~> source1",
						"source(output(",
						"          LATITUDE as string,",
						"          LONGITUDE as string,",
						"          STORE_ID as string,",
						"          STORE_NAME as string,",
						"          WEB_ADDRESS as string,",
						"          updated_timestamp as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(\"stores/\",$curr_date))) ~> source2",
						"source(output(",
						"          ORDER_ID as string,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as string,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as string,",
						"          order_date as string,",
						"          updated_timestamp as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(\"orders/\",$curr_date))) ~> source3",
						"source(output(",
						"          ORDER_ID as short,",
						"          LINE_ITEM_ID as short,",
						"          PRODUCT_ID as short,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as short,",
						"          {order_items.txt} as string,",
						"          {\"UPDATED_TIMESTAMP\"} as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(\"order_items/\",$curr_date))) ~> source4",
						"source1 derive(updated_ts = currentUTC()) ~> derivedColumn1",
						"source2 derive(updated_ts = currentUTC()) ~> derivedColumn2",
						"source3 derive(updated_ts = currentUTC()) ~> derivedColumn3",
						"source4 cast(output(",
						"          ORDER_ID as string",
						"     ),",
						"     errors: true) ~> cast1",
						"derivedColumn3, derivedColumn4 join(source3@ORDER_ID == cast1@ORDER_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"cast1 derive(SUBTOTAL = UNIT_PRICE*QUANTITY,",
						"          ORDER_ITEM_ID = toInteger(concat(toString(ORDER_ID),toString(LINE_ITEM_ID)))) ~> derivedColumn4",
						"join1 alterRow(upsertIf(true())) ~> AlterRow1",
						"derivedColumn1 select(mapColumn(",
						"          PRODUCT_ID,",
						"          PRODUCT_NAME,",
						"          UNIT_PRICE,",
						"          updated_ts",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn2 select(mapColumn(",
						"          STORE_ID,",
						"          STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          updated_ts",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'orders',",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: true,",
						"     keys:['Order_Item_id'],",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ORDER_ITEM_ID,",
						"          ORDER_ID = source3@ORDER_ID,",
						"          ORDER_DATE = order_date,",
						"          CUSTOMER_ID,",
						"          ORDER_STATUS,",
						"          STORE_ID,",
						"          PRODUCT_ID,",
						"          UNIT_PRICE,",
						"          QUANTITY,",
						"          SUBTOTAL,",
						"          UPDATED_TIMESTAMP = updated_ts",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> sink3",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'STORES',",
						"     preSQLs: ([\"truncate table {$schema_name}.stores\"]),",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          STORE_ID,",
						"          STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          UPDATED_TIMESTAMP = updated_ts",
						"     )) ~> sink4",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'PRODUCTS',",
						"     preSQLs: ([\"truncate table {$schema_name}.products\"]),",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          PRODUCT_ID,",
						"          PRODUCT_NAME,",
						"          UNIT_PRICE,",
						"          UPDATED_TIMESTAMP = updated_ts",
						"     )) ~> sink5"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_raw_cleaned_parquet')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "raw to cleaned"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_parquet_datalake_landing",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_name as string",
						"}",
						"source(output(",
						"          ORDER_ID as string,",
						"          ORDER_DATETIME as string,",
						"          CUSTOMER_ID as string,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: '\"file_name\"',",
						"     format: 'parquet') ~> source1",
						"source1 derive(order_date = concat(substring(ORDER_DATETIME, 8, 2), '-', \r",
						"              substring(ORDER_DATETIME, 4, 3), '-', \r",
						"              substring(ORDER_DATETIME, 1, 2)),",
						"          updated_timestamp = currentUTC()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(concat(substring($file_name,1,instr($file_name,'.')-1),'/'),toString(currentDate('UTC'),'yyyy-MM-dd'))),",
						"     partitionFileNames:[(concat(substring($file_name,1,instr($file_name,'.')-1),'.parquet'))],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          ORDER_ID,",
						"          ORDER_DATETIME,",
						"          CUSTOMER_ID,",
						"          ORDER_STATUS,",
						"          STORE_ID,",
						"          order_date,",
						"          updated_timestamp",
						"     ),",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_parquet_datalake_landing')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_raw_cleaned_text')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "raw to cleaned"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_txt_datalake_landing",
								"type": "DatasetReference"
							},
							"name": "txt"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_name as string",
						"}",
						"source(output(",
						"          ORDER_ID as short,",
						"          LINE_ITEM_ID as short,",
						"          PRODUCT_ID as short,",
						"          UNIT_PRICE as double,",
						"          QUANTITY as short",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: ($file_name)) ~> txt",
						"txt derive({\"UPDATED_TIMESTAMP\"} = currentTimestamp()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(concat(substring($file_name,1,instr($file_name,\".\")-1),'/'),toString(currentDate('UTC'),'yyyy-MM-dd'))),",
						"     compressionCodec: 'snappy',",
						"     partitionFileNames:[(concat(substring($file_name,1,instr($file_name,\".\")-1),\".parquet\"))],",
						"     umask: 0777,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_txt_datalake_landing')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_raw_cleansed_json')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "raw to cleaned"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_json_datalake_landing",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_name as string",
						"}",
						"source(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'documentPerLine') ~> source1",
						"source1 derive(updated_timestamp = currentUTC()) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'parquet',",
						"     fileSystem: 'cleansed',",
						"     folderPath: (concat(concat(substring($file_name,1,instr($file_name,\".\")-1),'/'),toString(currentDate('UTC'),'yyyy-MM-dd'))),",
						"     partitionFileNames:[(concat(substring($file_name,1,instr($file_name,\".\")-1),\".parquet\"))],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_json_datalake_landing')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureDataLakeStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_structured_analytics')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "source1"
						},
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "source2"
						},
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "source3"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "sink1"
						},
						{
							"linkedService": {
								"referenceName": "AzureSqlDatabase1",
								"type": "LinkedServiceReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "cast1"
						},
						{
							"name": "select1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select2"
						},
						{
							"name": "filter2"
						},
						{
							"name": "aggregate2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     schema_name as string",
						"}",
						"source(output(",
						"          ORDER_ITEM_ID as integer,",
						"          ORDER_ID as integer,",
						"          ORDER_DATE as string,",
						"          CUSTOMER_ID as integer,",
						"          ORDER_STATUS as string,",
						"          STORE_ID as integer,",
						"          PRODUCT_ID as integer,",
						"          UNIT_PRICE as decimal(18,0),",
						"          QUANTITY as integer,",
						"          SUBTOTAL as decimal(18,0),",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'orders',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> source1",
						"source(output(",
						"          PRODUCT_ID as integer,",
						"          PRODUCT_NAME as string,",
						"          UNIT_PRICE as decimal(18,0),",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'products',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> source2",
						"source(output(",
						"          STORE_ID as integer,",
						"          STORE_NAME as string,",
						"          LATITUDE as decimal(18,0),",
						"          LONGITUDE as decimal(18,0),",
						"          UPDATED_TIMESTAMP as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'stores',",
						"     isolationLevel: 'READ_UNCOMMITTED') ~> source3",
						"source1, cast1 join(source1@PRODUCT_ID == cast1@PRODUCT_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"source2 cast(output(",
						"          PRODUCT_ID as short",
						"     ),",
						"     errors: true) ~> cast1",
						"join1 select(mapColumn(",
						"          ORDER_DATE,",
						"          ORDER_STATUS,",
						"          SUBTOTAL,",
						"          PRODUCT_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 filter(upper(ORDER_STATUS)!=\"CANCELLED\") ~> filter1",
						"filter1 derive(month_year = concat('20',substring(ORDER_DATE,1,2))+\"-\"+substring(ORDER_DATE,4,3)) ~> derivedColumn1",
						"derivedColumn1 aggregate(groupBy(PRODUCT_NAME,",
						"          month_year,",
						"          ORDER_STATUS),",
						"     TOTAL_AMOUNT = round(sum(SUBTOTAL),2)) ~> aggregate1",
						"source1, source3 join(source1@STORE_ID == source3@STORE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 derive(month_year = concat('20',substring(ORDER_DATE,1,2))+\"-\"+substring(ORDER_DATE,4,3)) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          ORDER_STATUS,",
						"          SUBTOTAL,",
						"          month_year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 filter(upper(ORDER_STATUS)!=\"CANCELLED\") ~> filter2",
						"filter2 aggregate(groupBy(STORE_NAME,",
						"          LATITUDE,",
						"          LONGITUDE,",
						"          ORDER_STATUS,",
						"          month_year),",
						"     TOTAL_AMOUNT = round(sum(SUBTOTAL),2)) ~> aggregate2",
						"aggregate1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: '$schema_name',",
						"     tableName: 'products_orders_monthly',",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     truncate: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     preCommands: ['rm -r /products_orders_monthly/*'],",
						"     postCommands: []) ~> sink1",
						"aggregate2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table',",
						"     store: 'sqlserver',",
						"     schemaName: ($schema_name),",
						"     tableName: 'stores_orders_monthly',",
						"     insertable: true,",
						"     updateable: false,",
						"     deletable: false,",
						"     upsertable: false,",
						"     truncate: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     preCommands: ['rm -r /stores_orders_monthly/*'],",
						"     postCommands: []) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		}
	]
}